{% extends "base.html" %}

{% block title %}Página Inicial - Rolling Recipes{% endblock %}

{% block content %}
<div class="text-center my-5">
    <!-- Título Principal -->
    <h1 class="display-4">A sua próxima receita favorita</h1>

    <!-- Container para a animação Lottie do dado (agora posicionado aqui) -->
    <div id="lottie-loader" class="d-none mt-4" 
         style="max-width: 400px; margin: 0 auto;">
        <lottie-player src="{{ url_for('static', filename='dice_6.json') }}" background="transparent" speed="1" loop autoplay />
    </div>

</div>

<!-- Área para exibir mensagens (ex: nenhuma receita encontrada) -->
<div id="message-display" class="alert alert-warning mt-4 text-center d-none" role="alert"></div>

<!-- Área onde a receita será exibida -->
<div id="recipe-display" class="row justify-content-center d-none">
    <div class="col-md-8">
        <div class="card shadow-sm">
            <div class="card-body">
                <h2 id="recipe-title" class="card-title"></h2>
                <h5 class="text-muted">Ingredientes:</h5>
                <ul id="recipe-ingredients" class="list-group list-group-flush">
                    <!-- Ingredientes serão inseridos aqui via JS -->
                </ul>
                <h5 class="mt-4 text-muted">Passos:</h5>
                <!-- As instruções serão renderizadas aqui como uma lista ordenada -->
                <ol id="recipe-instructions" class="ps-3"></ol>
                <!-- Botão de Favoritar -->
                <div class="mt-4">
                    <button id="favorite-btn" class="btn btn-outline-danger">
                        ❤️ Guardar nos Favoritos
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Container para os controlos, agora posicionado no final -->
<div id="initial-controls" class="text-center my-5">
    <p class="lead mt-3">Não sabe o que cozinhar? Clique no botão abaixo e nós damos-lhe uma ideia!</p>
    <button id="get-recipe-btn" class="btn btn-warning btn-lg mt-3">
        Encontrar Receita!
    </button>
    <div class="mt-5">
        <p class="lead">Quer afinar o resultado? Escreva um ingrediente e sorteamos apenas receitas que o tenham.</p>
        <form id="search-form" class="mt-3">
            <div class="row justify-content-center">
                <div class="col-12 col-md-8 col-lg-6">
                    <div class="input-group">
                        <input type="text" id="ingredient-input" class="form-control" placeholder="Ex: queijo, frango..." pattern="[A-Za-zÀ-ú\s-]+" title="Por favor, use apenas letras, espaços e hífens." maxlength="20">
                        <button id="search-recipe-btn" class="btn btn-warning" type="submit">Filtrar e Sortear</button>
                    </div>
                </div>
            </div>
        </form>
    </div>
</div>

{% endblock %}

{% block scripts %}
<script>
// Passa o estado de autenticação do Flask para o JavaScript
const isAuthenticated = {{ current_user.is_authenticated|tojson|safe }};
let currentRecipeId = null;

/**
 * Preenche a lista de ingredientes no cartão da receita.
 * @param {string[]} ingredients - A lista de ingredientes.
 */
function populateIngredients(ingredients) {
    const ingredientsList = document.getElementById('recipe-ingredients');
    ingredientsList.innerHTML = ''; // Limpa a lista anterior
    ingredients.forEach(ing => {
        const li = document.createElement('li');
        li.className = 'list-group-item';
        li.textContent = ing;
        ingredientsList.appendChild(li);
    });
}

/**
 * Preenche a lista de instruções no cartão da receita.
 * @param {string[]} steps - A lista de passos da receita.
 */
function populateInstructions(steps) {
    const instructionsList = document.getElementById('recipe-instructions');
    instructionsList.innerHTML = ''; // Limpa a lista anterior
    steps.forEach(step => {
        const li = document.createElement('li');
        li.textContent = step;
        instructionsList.appendChild(li);
    });
}

/**
 * Busca e exibe uma receita, mostrando o loader e tratando os erros.
 * @param {string} apiUrl - A URL da API para buscar a receita.
 * @param {HTMLButtonElement} triggerButton - O botão que iniciou a ação.
 */
async function fetchAndDisplayRecipe(apiUrl, triggerButton) {
    const originalButtonText = triggerButton.textContent;
    const recipeDisplay = document.getElementById('recipe-display');
    const lottieLoader = document.getElementById('lottie-loader');
    const messageDisplay = document.getElementById('message-display');

    // Esconde tudo e mostra a animação
    recipeDisplay.classList.add('d-none');
    messageDisplay.classList.add('d-none');
    lottieLoader.classList.remove('d-none'); // Mostra a animação
    
    // Desativa ambos os botões para prevenir múltiplos cliques
    document.getElementById('get-recipe-btn').disabled = true;
    document.getElementById('search-recipe-btn').disabled = true;
    triggerButton.textContent = 'A sortear...';

    try {
        // Garante que a animação seja visível por um tempo mínimo
        const minimumDelay = new Promise(resolve => setTimeout(resolve, 4000));

        const [response] = await Promise.all([
            fetch(apiUrl),
            minimumDelay
        ]);

        const data = await response.json();

        if (!response.ok) {
            // Se a API retornar um erro (ex: 404), mostra a mensagem de erro
            messageDisplay.textContent = data.error || 'Não foi possível obter a receita.';
            messageDisplay.classList.remove('d-none');
            lottieLoader.classList.add('d-none'); // Esconde a animação
            return; // Termina a execução aqui
        }

        const recipe = data;
        currentRecipeId = recipe._id.$oid;

        // Preenche os dados da receita
        document.getElementById('recipe-title').textContent = recipe.nome;
        populateInstructions(recipe.instrucoes);
        populateIngredients(recipe.ingredientes);

        // Mostra o card da receita
        lottieLoader.classList.add('d-none');
        recipeDisplay.classList.remove('d-none');
        recipeDisplay.classList.add('fade-in');
        
        // Rola a página suavemente para a receita encontrada
        recipeDisplay.scrollIntoView({ behavior: 'smooth', block: 'start' });

    } catch (error) {
        console.error('Erro ao buscar receita:', error);
        messageDisplay.textContent = 'Ocorreu um erro de comunicação ao buscar a receita. Tente novamente.';
        messageDisplay.classList.remove('d-none');
        lottieLoader.classList.add('d-none');
    } finally {
        // Reativa ambos os botões e restaura o texto original do botão clicado
        document.getElementById('get-recipe-btn').disabled = false;
        document.getElementById('search-recipe-btn').disabled = false;
        triggerButton.textContent = originalButtonText;
    }
}

document.addEventListener('DOMContentLoaded', function() {
    const getRecipeBtn = document.getElementById('get-recipe-btn');
    const searchForm = document.getElementById('search-form');

    // Evento para o botão de sorteio aleatório
    getRecipeBtn.addEventListener('click', () => {
        fetchAndDisplayRecipe('/api/recipe/random', getRecipeBtn);
    });

    // Lógica para o botão de favoritar
    const favoriteBtn = document.getElementById('favorite-btn');
    favoriteBtn.addEventListener('click', async () => {
        if (!isAuthenticated) {
            // Se o utilizador não estiver autenticado, mostra uma mensagem
            alert('Para guardar receitas nos favoritos, precisa de entrar ou registar-se!');
            return;
        }

        if (!currentRecipeId) return;

        try {
            const response = await fetch('/api/user/favorites/add', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ recipe_id: currentRecipeId }),
            });

            const result = await response.json();

            if (response.ok) {
                alert(result.message); // Ex: "Receita adicionada aos favoritos!"
            } else {
                throw new Error(result.error || 'Não foi possível adicionar aos favoritos.');
            }
        } catch (error) {
            console.error('Erro ao favoritar receita:', error);
            alert(error.message);
        }
    });

    // Evento para o formulário de busca por ingrediente
    searchForm.addEventListener('submit', (event) => {
        event.preventDefault(); // Impede o recarregamento da página

        const ingredientInput = document.getElementById('ingredient-input');
        const searchBtn = document.getElementById('search-recipe-btn');
        const ingredient = ingredientInput.value.trim();

        // Validação: Verifica se o campo de ingrediente está vazio
        if (!ingredient) {
            // Define uma mensagem de erro personalizada
            ingredientInput.setCustomValidity('Para filtrar, por favor preencha este campo.');
            // Mostra a "bolha" de validação do navegador
            ingredientInput.reportValidity();
            // Limpa a mensagem de erro após um curto período para que o utilizador possa continuar
            setTimeout(() => {
                ingredientInput.setCustomValidity('');
            }, 2000);
            return; // Interrompe a execução se o campo estiver vazio
        }

        let apiUrl = '/api/recipe/random';
        apiUrl += `?ingredient=${encodeURIComponent(ingredient)}`;
        fetchAndDisplayRecipe(apiUrl, searchBtn);
    });

    // Validação em tempo real que impede a escrita de caracteres inválidos
    // e mostra a mensagem de validação nativa do navegador.
    const ingredientInput = document.getElementById('ingredient-input');
    ingredientInput.addEventListener('input', function () {
        const invalidCharsRegex = /[^A-Za-zÀ-ú\s-]/g;
        const currentValue = this.value;

        if (invalidCharsRegex.test(currentValue)) {
            // Define uma mensagem de erro personalizada.
            this.setCustomValidity('Só são permitidas letras, espaços e hífens.');
            // Força o navegador a mostrar a "bolha" de validação.
            this.reportValidity();
            // Remove os caracteres inválidos.
            this.value = currentValue.replace(invalidCharsRegex, '');
            // Limpa a mensagem de erro após um curto período para que o utilizador possa continuar.
            setTimeout(() => {
                this.setCustomValidity('');
            }, 1500);
        }
    });
});
</script>
{% endblock %}